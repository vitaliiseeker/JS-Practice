{"mappings":"AACA,MAEMA,EAAU,IAAIC,SAAQ,CAACC,EAASC,KACpCC,YAAW,KAIPD,EAAO,yCAAyC,GAEjD,IAAK,IAIVE,QAAQC,IAAI,yBAGZN,EAAQO,MAENC,IACEH,QAAQC,IAAI,wCACZD,QAAQC,IAAIE,EAAM,IAGpBC,IACEJ,QAAQC,IAAI,uCACZD,QAAQC,IAAIG,EAAM,IAKtBJ,QAAQC,IAAI,wBAIK,IAAIL,SAAQ,CAACC,EAASC,KACrCC,YAAW,KACTF,EAAQ,EAAE,GACT,IAAK,IAIPK,MAAKC,IACJH,QAAQC,IAAIE,GACG,EAARA,KAERD,MAAKC,IACJH,QAAQC,IAAIE,GACG,EAARA,KAERD,MAAKC,IACJH,QAAQC,IAAIE,EAAM,IAEnBE,OAAMD,IACLJ,QAAQC,IAAIG,EAAM,IAEnBE,SAAQ,KACPN,QAAQC,IAAI,aAAa,IAKD,IAACM,EAAUC,EAAVD,EAuBT,QAvBmBC,EAehBC,IACrBT,QAAQC,IAAIQ,EAAK,EAfjBT,QAAQC,IAAI,qBAAqBM,KAEjCR,YAAW,KAKPS,EAAU,gBAEM,GAEjB,KAewB,CAAAD,GACpB,IAAIX,SAAQ,CAACC,EAASC,KAC3BE,QAAQC,IAAI,qBAAqBM,KAEjCR,YAAW,KAOPD,EAAO,QAAQ,GAEhB,IAAK,IAIZY,CAAqB,SAClBR,MAAKO,GAAQT,QAAQC,IAAIQ,KACzBJ,OAAMD,GAASJ,QAAQI,MAAMA,KAIhC,MAAMO,EAAc,CAACC,EAAMC,IAClB,IAAIjB,SAAQC,IACjBE,YAAW,IAAMF,EAAQe,IAAOC,EAAM,IAIpCC,EAAWH,EAAY,iBAAkB,KACzCI,EAAWJ,EAAY,iBAAkB,KAE/Cf,QAAQoB,IAAI,CAACF,EAAUC,IACpBb,MAAKC,GAASH,QAAQC,IAAIE,KAC1BE,OAAMD,GAASJ,QAAQC,IAAIG,KAI9B,MAAMa,EAAe,CAACL,EAAMC,IACnB,IAAIjB,SAAQC,IACjBE,YAAW,IAAMF,EAAQe,IAAOC,EAAM,IAIpCK,EAAYD,EAAa,kBAAmB,KAC5CE,EAAYF,EAAa,kBAAmB,KAElDrB,QAAQwB,KAAK,CAACF,EAAWC,IACtBjB,MAAKC,GAASH,QAAQC,IAAIE,KAC1BE,OAAMD,GAASJ,QAAQC,IAAIG,KAK9B,IAAIR,SAAQC,GAAWA,EAAQ,mBAAkBK,MAAKC,GACpDH,QAAQC,IAAIE,KAGdP,QAAQC,QAAQ,iBAAiBK,MAAKC,GAASH,QAAQC,IAAIE,KAG3D,IAAIP,SAAQ,CAACC,EAASC,IAAWA,EAAO,WAAUO,OAAMD,GACtDJ,QAAQI,MAAMA,KAGhBR,QAAQE,OAAO,SAASO,OAAMD,GAASJ,QAAQI,MAAMA,KAM0F,MAczIiB,EAbc,MADCC,EAcO,eAbYC,IAAdD,EACf,CACLE,SAAS,EACTC,QAAS,gCAIN,CACLD,SAAS,EACTC,QAAS,WAAWH,KAVH,IAAAA,EAgBjBD,EAAOG,QACTxB,QAAQC,IAAIoB,EAAOI,SAEnBzB,QAAQI,MAAMiB,EAAOI,SAOD,EAACH,EAAWd,EAAWkB,KAC3C,GAAkB,KAAdJ,QAAkCC,IAAdD,EACtB,OAAOI,EAAQ,gCAEjBlB,EAAU,WAAWc,IAAY,EAGnCK,CACE,SACAC,GAAY5B,QAAQC,IAAI2B,KACxBxB,GAASJ,QAAQI,MAAMA,KAmBzBJ,QAAQC,IAAI,gBAEZF,YAAW,WACTC,QAAQC,IAAI,a,GACX,GAEHL,QAAQC,UACLK,MAAK,WACJF,QAAQC,IAAI,W,IAEbC,MAAK,WACJF,QAAQC,IAAI,W,IAGhBD,QAAQC,IAAI","sources":["src/js/09_05_promise.js"],"sourcesContent":["// Change value of isSuccess variable to call resolve or reject\nconst isSuccess = false;\n\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (isSuccess) {\n      resolve(\"Success! Value passed to resolve function\");\n    } else {\n      reject(\"Error! Error passed to reject function\");\n    }\n  }, 2000);\n});\n\n// Will run first\nconsole.log(\"Before promise.then()\");\n\n// Registering promise callbacks\npromise.then(\n  // onResolve will run third or not at all\n  value => {\n    console.log(\"onResolve call inside promise.then()\");\n    console.log(value); // \"Success! Value passed to resolve function\"\n  },\n  // onReject will run third or not at all\n  error => {\n    console.log(\"onReject call inside promise.then()\");\n    console.log(error); // \"Error! Error passed to reject function\"\n  }\n);\n\n// Will run second\nconsole.log(\"After promise.then()\");\n\n//---------------------------------\n\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(5);\n  }, 2000);\n});\n\npromise1\n  .then(value => {\n    console.log(value); // 5\n    return value * 2;\n  })\n  .then(value => {\n    console.log(value); // 10\n    return value * 3;\n  })\n  .then(value => {\n    console.log(value); // 30\n  })\n  .catch(error => {\n    console.log(error);\n  })\n  .finally(() => {\n    console.log(\"Final task\");\n  });\n\n//-----------------------\n\nconst fetchUserFromServer = (username, onSuccess, onError) => {\n  console.log(`Fetching data for ${username}`);\n\n  setTimeout(() => {\n    // Change value of isSuccess variable to simulate request status\n    const isSuccess = true;\n\n    if (isSuccess) {\n      onSuccess(\"success value\");\n    } else {\n      onError(\"error\");\n    }\n  }, 2000);\n};\n\nconst onFetchSuccess = user => {\n  console.log(user);\n};\n\nconst onFetchError = error => {\n  console.error(error);\n};\n\nfetchUserFromServer(\"Mango\", onFetchSuccess, onFetchError);\n\n//--------------------------------------------\n\nconst fetchUserFromServer1 = username => {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching data for ${username}`);\n\n    setTimeout(() => {\n      // Change value of isSuccess variable to simulate request status\n      const isSuccess = false;\n\n      if (isSuccess) {\n        resolve(\"success value\");\n      } else {\n        reject(\"error\");\n      }\n    }, 2000);\n  });\n};\n\nfetchUserFromServer1(\"Mango\")\n  .then(user => console.log(user))\n  .catch(error => console.error(error));\n\n//-----------------------------------------\n\nconst makePromise = (text, delay) => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(text), delay);\n  });\n};\n\nconst promiseA = makePromise(\"promiseA value\", 1000);\nconst promiseB = makePromise(\"promiseB value\", 3000);\n\nPromise.all([promiseA, promiseB])\n  .then(value => console.log(value)) //[\"promiseA value\", \"promiseB value\"]\n  .catch(error => console.log(error));\n\n//----------------------------------------------------\n\nconst makePromise1 = (text, delay) => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(text), delay);\n  });\n};\n\nconst promiseA1 = makePromise1(\"promiseA1 value\", 1000);\nconst promiseB1 = makePromise1(\"promiseB1 value\", 3000);\n\nPromise.race([promiseA1, promiseB1])\n  .then(value => console.log(value)) // \"promiseA value\"\n  .catch(error => console.log(error));\n\n//-----------------------------------------------------\n\n// Fulfilled promise\nnew Promise(resolve => resolve(\"success value\")).then(value =>\n  console.log(value)\n);\n\nPromise.resolve(\"success value\").then(value => console.log(value));\n\n// Rejected promise\nnew Promise((resolve, reject) => reject(\"error\")).catch(error =>\n  console.error(error)\n);\n\nPromise.reject(\"error\").catch(error => console.error(error));\n\n//-----------------------------------------------------\n\n// Ці методи використовуються для промісифікаціі функцій, коли необхідно побудувати ланцюжок промісів і вже є початкове значення.Виконаємо рефакторинг наступного коду.\n\nconst makeGreeting = guestName => {\n  if (guestName === \"\" || guestName === undefined) {\n    return {\n      success: false,\n      message: \"Guest name must not be empty\",\n    };\n  }\n\n  return {\n    success: true,\n    message: `Welcome ${guestName}`,\n  };\n};\n\nconst result = makeGreeting(\"Mango\");\n\nif (result.success) {\n  console.log(result.message);\n} else {\n  console.error(result.message);\n}\n\n//-----------------------------------------------------\n\n// Використовуючи колбек, відпадає необхідність повертати складні об'єкти зі статусом операції і перевіряти його у зовнішньому коді.\n\nconst makeGreeting1 = (guestName, onSuccess, onError) => {\n  if (guestName === \"\" || guestName === undefined) {\n    return onError(\"Guest name must not be empty\");\n  }\n  onSuccess(`Welcome ${guestName}`);\n};\n\nmakeGreeting1(\n  \"Mango\",\n  greeting => console.log(greeting),\n  error => console.error(error)\n);\n\n//-----------------------------------------------------\n// Останнім кроком буде промісифікація функції makeGreeting() для того, щоб повністю усунути її залежність від зовнішнього коду.\n\nconst makeGreeting2 = guestName => {\n  if (guestName === \"\" || guestName === undefined) {\n    return Promise.reject(\"Guest name must not be empty\");\n  }\n\n  Promise.resolve(`Welcome ${guestName}`);\n};\n\n// makeGreeting2(\"Mango\").then(greeting => console.log(greeting))\n//   .catch(error => console.error(error));\n\n//-----------------------------------------------------\n\nconsole.log('script start');\n\nsetTimeout(function () {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve()\n  .then(function () {\n    console.log('promise1');\n  })\n  .then(function () {\n    console.log('promise2');\n  });\n\nconsole.log('script end');\n\n  //-----------------------------------------------------\n\n\n\n  //-----------------------------------------------------\n\n"],"names":["$22d8c82c27d7515a$var$promise","Promise","resolve","reject","setTimeout","console","log","then","value","error","catch","finally","username","onSuccess","user","$22d8c82c27d7515a$var$fetchUserFromServer1","$22d8c82c27d7515a$var$makePromise","text","delay","$22d8c82c27d7515a$var$promiseA","$22d8c82c27d7515a$var$promiseB","all","$22d8c82c27d7515a$var$makePromise1","$22d8c82c27d7515a$var$promiseA1","$22d8c82c27d7515a$var$promiseB1","race","$22d8c82c27d7515a$var$result","guestName","undefined","success","message","onError","$22d8c82c27d7515a$var$makeGreeting1","greeting"],"version":3,"file":"09_05_promise.95afb0e8.js.map"}